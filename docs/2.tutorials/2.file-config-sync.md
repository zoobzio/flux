---
title: File Config Sync
description: Complete tutorial for file-based configuration synchronization with flux.
author: Flux Team
published: 2025-12-03
tags: [Tutorial, File, Configuration]
---

# File Config Sync

A complete example of file-based configuration synchronization with observability, error handling, and graceful shutdown.

## Project Structure

```
myapp/
├── main.go
├── config.yaml
└── go.mod
```

## Configuration Type

Define your configuration with struct tags for automatic parsing and validation:

```go
// config.go
package main

import "time"

// Config defines the application configuration
type Config struct {
    Server   ServerConfig   `yaml:"server"`
    Database DatabaseConfig `yaml:"database"`
    Features FeatureFlags   `yaml:"features"`
}

type ServerConfig struct {
    Port         int           `yaml:"port" validate:"min=1,max=65535"`
    ReadTimeout  time.Duration `yaml:"read_timeout" validate:"min=1s"`
    WriteTimeout time.Duration `yaml:"write_timeout" validate:"min=1s"`
}

type DatabaseConfig struct {
    URL             string `yaml:"url" validate:"required"`
    MaxConnections  int    `yaml:"max_connections" validate:"min=1"`
    IdleConnections int    `yaml:"idle_connections" validate:"min=0"`
}

type FeatureFlags struct {
    EnableMetrics bool `yaml:"enable_metrics"`
    EnableTracing bool `yaml:"enable_tracing"`
    DebugMode     bool `yaml:"debug_mode"`
}
```

Flux uses [go-playground/validator](https://github.com/go-playground/validator) for struct tag validation. Common tags:
- `required` - Field must not be zero value
- `min=N`, `max=N` - Numeric bounds
- `oneof=a b c` - Must be one of listed values
- `url`, `email` - Format validation

## Config File

```yaml
# config.yaml
server:
  port: 8080
  read_timeout: 30s
  write_timeout: 30s

database:
  url: postgres://localhost:5432/myapp
  max_connections: 100
  idle_connections: 10

features:
  enable_metrics: true
  enable_tracing: false
  debug_mode: false
```

## Main Application

```go
// main.go
package main

import (
    "context"
    "log"
    "os"
    "os/signal"
    "sync/atomic"
    "time"

    "github.com/zoobzio/capitan"
    "github.com/zoobzio/flux"
)

// Application holds the running application state
type Application struct {
    config atomic.Pointer[Config]
}

func (a *Application) Config() Config {
    return *a.config.Load()
}

func (a *Application) UpdateConfig(cfg Config) error {
    log.Printf("Applying config: port=%d, max_conn=%d, debug=%v",
        cfg.Server.Port,
        cfg.Database.MaxConnections,
        cfg.Features.DebugMode,
    )

    // Here you would:
    // - Reconfigure server timeouts
    // - Resize connection pools
    // - Toggle feature flags
    // - etc.

    a.config.Store(&cfg)
    return nil
}

func main() {
    app := &Application{}

    // Set up observability
    setupObservability()

    // Create capacitor - flux handles parsing and validation automatically
    capacitor := flux.New[Config](
        flux.NewFileWatcher("config.yaml"),
        func(cfg Config) error {
            // Only called with valid, parsed config
            return app.UpdateConfig(cfg)
        },
        flux.WithDebounce(100*time.Millisecond),
    )

    // Start watching
    ctx, cancel := signal.NotifyContext(context.Background(), os.Interrupt)
    defer cancel()

    log.Println("Starting configuration watcher...")

    if err := capacitor.Start(ctx); err != nil {
        log.Printf("WARNING: Initial config failed: %v", err)
        log.Println("Continuing to watch for valid configuration...")
    }

    // Log initial state
    logState(capacitor)

    // Block until interrupt
    <-ctx.Done()

    log.Println("Shutting down...")
}

func setupObservability() {
    // Log all state changes
    capitan.Hook(flux.CapacitorStateChanged, func(ctx context.Context, e *capitan.Event) {
        oldState, _ := flux.KeyOldState.From(e)
        newState, _ := flux.KeyNewState.From(e)
        log.Printf("Config state: %s → %s", oldState, newState)
    })

    // Log change detection
    capitan.Hook(flux.CapacitorChangeReceived, func(ctx context.Context, e *capitan.Event) {
        log.Println("Config file change detected")
    })

    // Log validation failures
    capitan.Hook(flux.CapacitorValidationFailed, func(ctx context.Context, e *capitan.Event) {
        errMsg, _ := flux.KeyError.From(e)
        log.Printf("Config validation failed: %s", errMsg)
    })

    // Log transform failures (YAML/JSON parse errors)
    capitan.Hook(flux.CapacitorTransformFailed, func(ctx context.Context, e *capitan.Event) {
        errMsg, _ := flux.KeyError.From(e)
        log.Printf("Config parse failed: %s", errMsg)
    })

    // Log successful applies
    capitan.Hook(flux.CapacitorApplySucceeded, func(ctx context.Context, e *capitan.Event) {
        log.Println("Config applied successfully")
    })
}

func logState[R any](c *flux.Capacitor[R]) {
    switch c.State() {
    case flux.StateHealthy:
        log.Println("Config status: HEALTHY")
    case flux.StateDegraded:
        log.Printf("Config status: DEGRADED (error: %v)", c.LastError())
    case flux.StateEmpty:
        log.Printf("Config status: EMPTY (error: %v)", c.LastError())
    case flux.StateLoading:
        log.Println("Config status: LOADING")
    }
}
```

## Running the Example

```bash
# Start the application
go run .

# Output:
# Starting configuration watcher...
# Config file change detected
# Applying config: port=8080, max_conn=100, debug=false
# Config applied successfully
# Config state: loading → healthy
# Config status: HEALTHY
```

## Testing Config Changes

```bash
# Valid change
sed -i 's/port: 8080/port: 9090/' config.yaml

# Output:
# Config file change detected
# Applying config: port=9090, max_conn=100, debug=false
# Config applied successfully
```

```bash
# Invalid change (port out of range)
sed -i 's/port: 9090/port: 99999/' config.yaml

# Output:
# Config file change detected
# Config validation failed: Key: 'Config.Server.Port' Error:Field validation for 'Port' failed on the 'max' tag
# Config state: healthy → degraded
```

```bash
# Recovery (fix the port)
sed -i 's/port: 99999/port: 8080/' config.yaml

# Output:
# Config file change detected
# Applying config: port=8080, max_conn=100, debug=false
# Config applied successfully
# Config state: degraded → healthy
```

## Business Rule Validation

For validation beyond struct tags, add checks in your callback:

```go
capacitor := flux.New[Config](
    flux.NewFileWatcher("config.yaml"),
    func(cfg Config) error {
        // Business rule: idle cannot exceed max
        if cfg.Database.IdleConnections > cfg.Database.MaxConnections {
            return errors.New("idle_connections cannot exceed max_connections")
        }
        return app.UpdateConfig(cfg)
    },
)
```

## Integration with HTTP Server

```go
func startServer(app *Application) *http.Server {
    mux := http.NewServeMux()

    mux.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
        cfg := app.Config()
        w.WriteHeader(http.StatusOK)
        fmt.Fprintf(w, "OK - debug=%v\n", cfg.Features.DebugMode)
    })

    mux.HandleFunc("/config", func(w http.ResponseWriter, r *http.Request) {
        cfg := app.Config()
        json.NewEncoder(w).Encode(cfg)
    })

    cfg := app.Config()
    server := &http.Server{
        Addr:         fmt.Sprintf(":%d", cfg.Server.Port),
        Handler:      mux,
        ReadTimeout:  cfg.Server.ReadTimeout,
        WriteTimeout: cfg.Server.WriteTimeout,
    }

    go server.ListenAndServe()

    return server
}
```

## Testing

```go
func TestConfigReload(t *testing.T) {
    ch := make(chan []byte, 2)

    // Initial config
    ch <- []byte(`
server:
  port: 8080
  read_timeout: 30s
  write_timeout: 30s
database:
  url: postgres://localhost/test
  max_connections: 10
  idle_connections: 2
features:
  enable_metrics: false
  enable_tracing: false
  debug_mode: false
`)

    // Updated config
    ch <- []byte(`
server:
  port: 9090
  read_timeout: 60s
  write_timeout: 60s
database:
  url: postgres://localhost/test
  max_connections: 20
  idle_connections: 5
features:
  enable_metrics: true
  enable_tracing: true
  debug_mode: true
`)

    var applied Config

    capacitor := flux.New[Config](
        flux.NewSyncChannelWatcher(ch),
        func(cfg Config) error {
            applied = cfg
            return nil
        },
        flux.WithSyncMode(),
    )

    ctx := context.Background()

    // Initial load
    err := capacitor.Start(ctx)
    require.NoError(t, err)
    assert.Equal(t, 8080, applied.Server.Port)
    assert.False(t, applied.Features.DebugMode)

    // Reload
    capacitor.Process(ctx)
    assert.Equal(t, 9090, applied.Server.Port)
    assert.True(t, applied.Features.DebugMode)
}
```

## Next Steps

- [Testing Guide](../3.guides/1.testing.md) - More testing patterns
- [Custom Watchers](../3.guides/2.custom-watchers.md) - Watch other sources
- [State Management](../3.guides/3.state-management.md) - Advanced state handling
