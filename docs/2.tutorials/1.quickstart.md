---
title: Quickstart
description: Get started with flux in 5 minutes.
author: Flux Team
published: 2025-12-03
tags: [Tutorial, Quickstart, Getting Started]
---

# Quickstart

Get reactive configuration sync running in 5 minutes.

## Installation

```bash
go get github.com/zoobzio/flux
```

## Basic Example

Watch a YAML config file and automatically reload on changes:

```go
package main

import (
    "context"
    "log"
    "os"
    "os/signal"

    "github.com/zoobzio/flux"
)

// Config uses struct tags for both unmarshaling and validation.
// Flux automatically:
// 1. Detects YAML/JSON format
// 2. Unmarshals using yaml/json tags
// 3. Validates using validate tags (go-playground/validator)
// 4. Only calls your callback if everything passes
type Config struct {
    ServerPort     int    `yaml:"server_port" validate:"min=1,max=65535"`
    DatabaseURL    string `yaml:"database_url" validate:"required"`
    MaxConnections int    `yaml:"max_connections" validate:"min=1"`
}

func main() {
    // Create capacitor - just provide watcher and callback!
    capacitor := flux.New[Config](
        // Watch this file
        flux.NewFileWatcher("/etc/myapp/config.yaml"),

        // Callback: Only called with valid, parsed config
        func(cfg Config) error {
            log.Printf("Config applied: port=%d, max_conn=%d",
                cfg.ServerPort, cfg.MaxConnections)
            return nil
        },
    )

    // Start watching
    ctx, cancel := signal.NotifyContext(context.Background(), os.Interrupt)
    defer cancel()

    if err := capacitor.Start(ctx); err != nil {
        log.Printf("Initial config error: %v", err)
        // Capacitor continues watching for valid config
    }

    // Check state
    switch capacitor.State() {
    case flux.StateHealthy:
        log.Println("Config loaded successfully")
    case flux.StateEmpty:
        log.Println("Waiting for valid config...")
    }

    // Block until interrupt
    <-ctx.Done()
    log.Println("Shutting down")
}
```

## Create a Config File

```yaml
# /etc/myapp/config.yaml
server_port: 8080
database_url: postgres://localhost/myapp
max_connections: 100
```

## Run and Test

```bash
# Start your application
go run main.go
# Output: Config applied: port=8080, max_conn=100
# Output: Config loaded successfully

# In another terminal, modify the config
echo "server_port: 9090
database_url: postgres://localhost/myapp
max_connections: 200" > /etc/myapp/config.yaml
# Output: Config applied: port=9090, max_conn=200

# Try invalid config
echo "server_port: -1
database_url: postgres://localhost/myapp
max_connections: 200" > /etc/myapp/config.yaml
# Output: (no apply - validation failed due to min=1 constraint)
# State becomes Degraded, previous config retained
```

## Accessing Current Config

```go
// Get the current valid configuration
cfg, ok := capacitor.Current()
if !ok {
    // No valid config (Loading or Empty state)
    return
}

// Use cfg safely
fmt.Printf("Using port %d\n", cfg.ServerPort)
```

## Handling Errors

```go
// Check for errors
if err := capacitor.LastError(); err != nil {
    log.Printf("Config error: %v", err)
}

// State indicates overall health
switch capacitor.State() {
case flux.StateHealthy:
    // All good
case flux.StateDegraded:
    // Last update failed, using previous config
    cfg, _ := capacitor.Current() // Still valid
    log.Printf("Using fallback config, error: %v", capacitor.LastError())
case flux.StateEmpty:
    // Never got a valid config
    log.Fatal("No valid configuration available")
}
```

## Configuration Options

```go
capacitor := flux.New[Config](
    watcher,
    callback,

    // Custom debounce duration (default: 100ms)
    flux.WithDebounce(200*time.Millisecond),
)
```

## Validation Tags

Flux uses [go-playground/validator](https://github.com/go-playground/validator). Common tags:

```go
type Config struct {
    Port     int    `validate:"min=1,max=65535"`      // Range
    Host     string `validate:"required"`              // Required
    URL      string `validate:"url"`                   // URL format
    Email    string `validate:"email"`                 // Email format
    Timeout  int    `validate:"gte=0,lte=300"`        // Greater/less than
    LogLevel string `validate:"oneof=debug info warn"` // Enum
}
```

For complex validation (field dependencies, business rules), return an error from your callback:

```go
capacitor := flux.New[Config](
    watcher,
    func(cfg Config) error {
        // Business rule: checkout requires cart
        if cfg.EnableCheckout && !cfg.EnableCart {
            return errors.New("checkout requires cart")
        }
        return app.SetConfig(cfg)
    },
)
```

## Next Steps

- [File Config Sync](./2.file-config-sync.md) - Complete worked example
- [Core Concepts](../1.learn/2.core-concepts.md) - Understanding capacitors and state
- [Testing Guide](../3.guides/1.testing.md) - Testing your configuration sync
