---
title: State Management
description: Handling state transitions and rollback in flux.
author: Flux Team
published: 2025-12-03
tags: [Guide, State, Rollback, Error Handling]
---

# State Management

Flux maintains a state machine that tracks configuration health. This guide covers how to work with states, handle failures, and implement recovery patterns.

## State Overview

```
┌─────────┐   valid    ┌─────────┐
│ Loading │──────────▶│ Healthy │◀──┐
└─────────┘            └─────────┘   │
     │                      │        │
     │ invalid              │ invalid│ valid
     ▼                      ▼        │
┌─────────┐            ┌─────────┐───┘
│  Empty  │            │ Degraded│
└─────────┘            └─────────┘
```

| State | Has Valid Config | Error Present | Meaning |
|-------|------------------|---------------|---------|
| Loading | No | No | Waiting for first value |
| Healthy | Yes | No | Valid config active |
| Degraded | Yes | Yes | Update failed, previous config retained |
| Empty | No | Yes | No valid config ever obtained |

## Checking State

```go
switch capacitor.State() {
case flux.StateLoading:
    // Still initializing
    log.Println("Waiting for configuration...")

case flux.StateHealthy:
    // All good
    cfg, _ := capacitor.Current()
    log.Printf("Using config: %+v", cfg)

case flux.StateDegraded:
    // Failed update, but have fallback
    cfg, _ := capacitor.Current()
    err := capacitor.LastError()
    log.Printf("Using fallback config due to: %v", err)

case flux.StateEmpty:
    // Critical - no valid config
    err := capacitor.LastError()
    log.Fatalf("No valid configuration: %v", err)
}
```

## Handling Initial Load Failure

When the first configuration fails to load:

```go
err := capacitor.Start(ctx)
if err != nil {
    // Initial load failed
    // State is now Empty
    // But capacitor keeps watching for valid config

    if capacitor.State() == flux.StateEmpty {
        // Option 1: Fatal - application cannot run without config
        log.Fatalf("Cannot start without valid config: %v", err)

        // Option 2: Use hardcoded defaults, wait for valid config
        useDefaults()
        log.Printf("Using defaults, waiting for config: %v", err)

        // Option 3: Retry with backoff
        go retryUntilHealthy(capacitor)
    }
}
```

### Retry Pattern

```go
func retryUntilHealthy[R any](c *flux.Capacitor[R]) {
    ticker := time.NewTicker(5 * time.Second)
    defer ticker.Stop()

    for range ticker.C {
        if c.State() == flux.StateHealthy {
            log.Println("Configuration recovered")
            return
        }
        log.Printf("Still waiting for valid config: %v", c.LastError())
    }
}
```

## Handling Degraded State

When an update fails but previous config is retained:

```go
// Set up monitoring
capitan.Hook(flux.CapacitorStateChanged, func(ctx context.Context, e *capitan.Event) {
    newState, _ := flux.KeyNewState.From(e)

    if newState == flux.StateDegraded.String() {
        // Alert on degradation
        alerting.Send(alert{
            Severity: "warning",
            Message:  "Config update failed, using previous version",
        })
    }
})
```

### Degraded State Metrics

```go
func monitorState[R any](c *flux.Capacitor[R]) {
    ticker := time.NewTicker(10 * time.Second)
    defer ticker.Stop()

    for range ticker.C {
        state := c.State()
        metrics.Gauge("config_state", stateToNumber(state))

        if state == flux.StateDegraded {
            metrics.Increment("config_degraded_seconds", 10)
        }
    }
}

func stateToNumber(s flux.State) float64 {
    switch s {
    case flux.StateHealthy:
        return 1
    case flux.StateDegraded:
        return 0.5
    case flux.StateEmpty:
        return 0
    default:
        return -1
    }
}
```

## Recovery Patterns

### Automatic Recovery

Recovery happens automatically when a valid config arrives:

```go
// State: Degraded (last update failed)
// New valid config arrives...
// State: Healthy (automatically)

capitan.Hook(flux.CapacitorStateChanged, func(ctx context.Context, e *capitan.Event) {
    old, _ := flux.KeyOldState.From(e)
    new, _ := flux.KeyNewState.From(e)

    if old == flux.StateDegraded.String() && new == flux.StateHealthy.String() {
        log.Println("Configuration recovered from degraded state")
        alerting.Resolve("config_degraded")
    }
})
```

### Manual Recovery (File Watcher)

If using file-based config, recovery is triggered by fixing and saving the file:

```bash
# Fix the config file
vim /etc/myapp/config.yaml

# Save triggers fsnotify event
# Flux processes new value
# If valid: State → Healthy
```

## Error Classification

Flux provides different signals for different error types:

```go
// Unmarshal errors - YAML/JSON syntax problems
capitan.Hook(flux.CapacitorTransformFailed, func(ctx context.Context, e *capitan.Event) {
    errMsg, _ := flux.KeyError.From(e)
    log.Printf("Config parse error: %s", errMsg)
    metrics.Increment("config_parse_errors")
})

// Validation errors - struct tag violations
capitan.Hook(flux.CapacitorValidationFailed, func(ctx context.Context, e *capitan.Event) {
    errMsg, _ := flux.KeyError.From(e)
    log.Printf("Config validation error: %s", errMsg)
    metrics.Increment("config_validation_errors")
})

// Callback errors - application-level issues
capitan.Hook(flux.CapacitorApplyFailed, func(ctx context.Context, e *capitan.Event) {
    errMsg, _ := flux.KeyError.From(e)
    log.Printf("Config apply error: %s", errMsg)
    metrics.Increment("config_apply_errors")
})
```

## Graceful Degradation

Design your application to handle degraded state gracefully:

```go
type Application struct {
    capacitor *flux.Capacitor[Config]
}

func (a *Application) Config() Config {
    cfg, ok := a.capacitor.Current()
    if !ok {
        // No valid config - use safe defaults
        return Config{
            MaxConnections: 10,
            Timeout:        30 * time.Second,
            DebugMode:      false,
        }
    }
    return cfg
}

func (a *Application) IsHealthy() bool {
    return a.capacitor.State() == flux.StateHealthy
}

func (a *Application) IsDegraded() bool {
    return a.capacitor.State() == flux.StateDegraded
}
```

### Health Check Endpoint

```go
func (a *Application) HealthHandler(w http.ResponseWriter, r *http.Request) {
    state := a.capacitor.State()

    response := struct {
        Status string `json:"status"`
        Config string `json:"config"`
        Error  string `json:"error,omitempty"`
    }{
        Status: state.String(),
    }

    switch state {
    case flux.StateHealthy:
        w.WriteHeader(http.StatusOK)
        response.Config = "current"

    case flux.StateDegraded:
        w.WriteHeader(http.StatusOK) // Still serving
        response.Config = "previous"
        if err := a.capacitor.LastError(); err != nil {
            response.Error = err.Error()
        }

    case flux.StateEmpty:
        w.WriteHeader(http.StatusServiceUnavailable)
        response.Config = "none"
        if err := a.capacitor.LastError(); err != nil {
            response.Error = err.Error()
        }

    default:
        w.WriteHeader(http.StatusServiceUnavailable)
        response.Config = "loading"
    }

    json.NewEncoder(w).Encode(response)
}
```

## State Transition Events

All transitions emit capitan signals:

```go
// Complete state tracking
var stateHistory []StateChange

capitan.Hook(flux.CapacitorStateChanged, func(ctx context.Context, e *capitan.Event) {
    old, _ := flux.KeyOldState.From(e)
    new, _ := flux.KeyNewState.From(e)
    stateHistory = append(stateHistory, StateChange{
        Timestamp: time.Now(),
        From:      old,
        To:        new,
    })
})
```

## Next Steps

- [Testing Guide](./1.testing.md) - Testing state transitions
- [Custom Watchers](./2.custom-watchers.md) - Implementing data sources
- [API Reference](../4.reference/1.api.md) - Complete API documentation
