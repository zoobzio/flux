---
title: Testing Guide
description: Testing patterns for flux with sync mode and clockz.
author: Flux Team
published: 2025-12-03
tags: [Guide, Testing, Sync Mode, Clockz]
---

# Testing Guide

Flux provides two mechanisms for deterministic testing:

1. **Sync Mode** - Manual, step-by-step processing without goroutines
2. **Fake Clock** - Controlled time for debounce testing

## Sync Mode

Sync mode disables async processing, allowing you to control exactly when values are processed.

### Basic Usage

```go
type Config struct {
    Valid bool `yaml:"valid"`
}

func TestConfigValidation(t *testing.T) {
    ch := make(chan []byte, 2)
    ch <- []byte(`valid: true`)
    ch <- []byte(`valid: false`)

    var applied int

    capacitor := flux.New[Config](
        flux.NewSyncChannelWatcher(ch),
        func(cfg Config) error {
            if !cfg.Valid {
                return errors.New("invalid config")
            }
            applied++
            return nil
        },
        flux.WithSyncMode(),
    )

    ctx := context.Background()

    // Initial load - processed synchronously
    err := capacitor.Start(ctx)
    require.NoError(t, err)
    assert.Equal(t, 1, applied)
    assert.Equal(t, flux.StateHealthy, capacitor.State())

    // Second value - must call Process() explicitly
    capacitor.Process(ctx)
    assert.Equal(t, 1, applied)  // Not incremented - callback returned error
    assert.Equal(t, flux.StateDegraded, capacitor.State())
}
```

### Key Points

1. Use `flux.NewSyncChannelWatcher()` for direct channel access
2. Use `flux.WithSyncMode()` to disable async processing
3. Call `capacitor.Process(ctx)` to process each subsequent value
4. `Process()` returns `true` if a value was available, `false` otherwise

### SyncChannelWatcher vs ChannelWatcher

```go
// ChannelWatcher: Uses internal goroutine to forward values
// - Values may not be immediately available
// - Use for production or async testing
watcher := flux.NewChannelWatcher(ch)

// SyncChannelWatcher: Returns source channel directly
// - Values immediately available
// - Use with WithSyncMode() for deterministic tests
watcher := flux.NewSyncChannelWatcher(ch)
```

## Testing State Transitions

### Empty State (Initial Failure)

```go
type Config struct {
    Port int `yaml:"port" validate:"min=1"`
}

func TestInitialLoadFailure(t *testing.T) {
    ch := make(chan []byte, 1)
    ch <- []byte(`invalid yaml{{{`)

    capacitor := flux.New[Config](
        flux.NewSyncChannelWatcher(ch),
        func(cfg Config) error { return nil },
        flux.WithSyncMode(),
    )

    err := capacitor.Start(context.Background())

    assert.Error(t, err)
    assert.Equal(t, flux.StateEmpty, capacitor.State())
    assert.NotNil(t, capacitor.LastError())

    _, ok := capacitor.Current()
    assert.False(t, ok)  // No valid config
}
```

### Degraded State (Update Failure)

```go
type Config struct {
    Value int `yaml:"value" validate:"min=0"`
}

func TestUpdateFailure(t *testing.T) {
    ch := make(chan []byte, 2)
    ch <- []byte(`value: 42`)   // Valid
    ch <- []byte(`value: -1`)   // Invalid (min=0)

    capacitor := flux.New[Config](
        flux.NewSyncChannelWatcher(ch),
        func(cfg Config) error { return nil },
        flux.WithSyncMode(),
    )

    ctx := context.Background()

    // Initial load succeeds
    err := capacitor.Start(ctx)
    require.NoError(t, err)
    assert.Equal(t, flux.StateHealthy, capacitor.State())

    // Update fails validation
    capacitor.Process(ctx)
    assert.Equal(t, flux.StateDegraded, capacitor.State())

    // Previous config still available
    cfg, ok := capacitor.Current()
    assert.True(t, ok)
    assert.Equal(t, 42, cfg.Value)
}
```

### Recovery from Degraded

```go
func TestRecovery(t *testing.T) {
    ch := make(chan []byte, 3)
    ch <- []byte(`value: 42`)   // Valid
    ch <- []byte(`value: -1`)   // Invalid
    ch <- []byte(`value: 100`)  // Valid again

    capacitor := flux.New[Config](
        flux.NewSyncChannelWatcher(ch),
        func(cfg Config) error { return nil },
        flux.WithSyncMode(),
    )

    ctx := context.Background()
    capacitor.Start(ctx)

    // Fail
    capacitor.Process(ctx)
    assert.Equal(t, flux.StateDegraded, capacitor.State())

    // Recover
    capacitor.Process(ctx)
    assert.Equal(t, flux.StateHealthy, capacitor.State())
    assert.Nil(t, capacitor.LastError())

    cfg, _ := capacitor.Current()
    assert.Equal(t, 100, cfg.Value)
}
```

## Testing Debounce with Fake Clock

For testing debounce behavior, use `clockz.FakeClock`:

```go
import "github.com/zoobzio/clockz"

type Config struct {
    Value int `yaml:"value" validate:"min=0"`
}

func TestDebounceCoalescing(t *testing.T) {
    clock := clockz.NewFakeClock()
    ch := make(chan []byte, 10)
    ch <- []byte(`value: 1`)  // Initial

    var applyCount atomic.Int32
    var lastValue atomic.Int32

    capacitor := flux.New[Config](
        flux.NewChannelWatcher(ch),
        func(cfg Config) error {
            applyCount.Add(1)
            lastValue.Store(int32(cfg.Value))
            return nil
        },
        flux.WithDebounce(100*time.Millisecond),
        flux.WithClock(clock),
    )

    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()

    capacitor.Start(ctx)
    assert.Equal(t, int32(1), applyCount.Load())

    // Send rapid changes
    ch <- []byte(`value: 2`)
    ch <- []byte(`value: 3`)
    ch <- []byte(`value: 4`)
    time.Sleep(10 * time.Millisecond)  // Let goroutine receive

    // Still just initial apply
    assert.Equal(t, int32(1), applyCount.Load())

    // Advance past debounce
    clock.Advance(150 * time.Millisecond)
    clock.BlockUntilReady()
    time.Sleep(10 * time.Millisecond)

    // Now debounced value applied
    assert.Equal(t, int32(2), applyCount.Load())
    assert.Equal(t, int32(4), lastValue.Load())  // Latest value
}
```

## Testing Validation via Struct Tags

Flux uses go-playground/validator for struct tag validation:

```go
type Config struct {
    Port     int    `yaml:"port" validate:"min=1,max=65535"`
    Host     string `yaml:"host" validate:"required"`
    LogLevel string `yaml:"log_level" validate:"oneof=debug info warn error"`
}

func TestStructTagValidation(t *testing.T) {
    tests := []struct {
        name    string
        yaml    string
        wantErr bool
    }{
        {
            name:    "valid config",
            yaml:    "port: 8080\nhost: localhost\nlog_level: info",
            wantErr: false,
        },
        {
            name:    "port too low",
            yaml:    "port: 0\nhost: localhost\nlog_level: info",
            wantErr: true,
        },
        {
            name:    "missing required host",
            yaml:    "port: 8080\nlog_level: info",
            wantErr: true,
        },
        {
            name:    "invalid log level",
            yaml:    "port: 8080\nhost: localhost\nlog_level: verbose",
            wantErr: true,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            ch := make(chan []byte, 1)
            ch <- []byte(tt.yaml)

            capacitor := flux.New[Config](
                flux.NewSyncChannelWatcher(ch),
                func(cfg Config) error { return nil },
                flux.WithSyncMode(),
            )

            err := capacitor.Start(context.Background())
            if tt.wantErr {
                assert.Error(t, err)
                assert.Equal(t, flux.StateEmpty, capacitor.State())
            } else {
                assert.NoError(t, err)
                assert.Equal(t, flux.StateHealthy, capacitor.State())
            }
        })
    }
}
```

## Testing Callback Errors

```go
func TestCallbackError(t *testing.T) {
    ch := make(chan []byte, 1)
    ch <- []byte(`port: 8080\nhost: localhost`)

    capacitor := flux.New[Config](
        flux.NewSyncChannelWatcher(ch),
        func(cfg Config) error {
            return errors.New("database connection failed")
        },
        flux.WithSyncMode(),
    )

    err := capacitor.Start(context.Background())

    assert.Error(t, err)
    assert.Contains(t, err.Error(), "callback failed")
    assert.Equal(t, flux.StateEmpty, capacitor.State())
}
```

## Testing Double Start

```go
func TestDoubleStart(t *testing.T) {
    ch := make(chan []byte, 1)
    ch <- []byte(`port: 8080\nhost: localhost`)

    capacitor := flux.New[Config](
        flux.NewSyncChannelWatcher(ch),
        func(cfg Config) error { return nil },
        flux.WithSyncMode(),
    )

    ctx := context.Background()

    err1 := capacitor.Start(ctx)
    assert.NoError(t, err1)

    err2 := capacitor.Start(ctx)
    assert.Error(t, err2)
    assert.Contains(t, err2.Error(), "already started")
}
```

## Next Steps

- [Custom Watchers](./2.custom-watchers.md) - Testing custom watcher implementations
- [State Management](./3.state-management.md) - Testing state transition scenarios
- [API Reference](../4.reference/1.api.md) - Complete API documentation
