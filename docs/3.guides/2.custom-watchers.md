---
title: Custom Watchers
description: Implementing custom data source watchers for flux.
author: Flux Team
published: 2025-12-03
tags: [Guide, Watcher, Custom, Implementation]
---

# Custom Watchers

Flux ships with `FileWatcher` and `ChannelWatcher`. For other data sources, implement the `Watcher` interface.

## The Interface

```go
type Watcher interface {
    Watch(ctx context.Context) (<-chan []byte, error)
}
```

Watchers always emit raw bytes. Flux handles unmarshaling and validation via struct tags.

## Requirements

1. **Emit current value immediately** - The first emission enables initial load
2. **Emit on change** - Subsequent emissions trigger the unmarshal → validate → callback pipeline
3. **Close channel on shutdown** - When context is cancelled or source becomes unavailable
4. **Return error if watching cannot start** - e.g., invalid path, connection failure

## Example: Polling Watcher

A simple watcher that polls a function at intervals:

```go
type PollingWatcher struct {
    fetch    func(context.Context) ([]byte, error)
    interval time.Duration
}

func NewPollingWatcher(
    fetch func(context.Context) ([]byte, error),
    interval time.Duration,
) *PollingWatcher {
    return &PollingWatcher{
        fetch:    fetch,
        interval: interval,
    }
}

func (w *PollingWatcher) Watch(ctx context.Context) (<-chan []byte, error) {
    // Fetch initial value to validate source is accessible
    initial, err := w.fetch(ctx)
    if err != nil {
        return nil, fmt.Errorf("initial fetch failed: %w", err)
    }

    out := make(chan []byte)

    go func() {
        defer close(out)

        // Emit initial value
        select {
        case out <- initial:
        case <-ctx.Done():
            return
        }

        var current []byte = initial
        ticker := time.NewTicker(w.interval)
        defer ticker.Stop()

        for {
            select {
            case <-ctx.Done():
                return
            case <-ticker.C:
                next, err := w.fetch(ctx)
                if err != nil {
                    continue // Skip failed fetches
                }
                if !bytes.Equal(current, next) {
                    current = next
                    select {
                    case out <- current:
                    case <-ctx.Done():
                        return
                    }
                }
            }
        }
    }()

    return out, nil
}
```

### Usage

```go
type Config struct {
    Port int `json:"port" validate:"min=1,max=65535"`
}

watcher := NewPollingWatcher(
    func(ctx context.Context) ([]byte, error) {
        return httpGet(ctx, "https://config.example.com/app.json")
    },
    30*time.Second,
)

capacitor := flux.New[Config](watcher, func(cfg Config) error {
    return app.SetConfig(cfg)
})
```

## Testing Custom Watchers

```go
func TestPollingWatcher(t *testing.T) {
    callCount := 0
    fetch := func(ctx context.Context) ([]byte, error) {
        callCount++
        return []byte(fmt.Sprintf(`{"value": %d}`, callCount)), nil
    }

    watcher := NewPollingWatcher(fetch, 10*time.Millisecond)

    ctx, cancel := context.WithTimeout(context.Background(), 50*time.Millisecond)
    defer cancel()

    ch, err := watcher.Watch(ctx)
    require.NoError(t, err)

    // Should receive initial value
    val := <-ch
    assert.Equal(t, `{"value": 1}`, string(val))

    // Should receive subsequent values as they change
    val = <-ch
    assert.Equal(t, `{"value": 2}`, string(val))
}
```

## Common Patterns

**Deduplication** - Only emit when value actually changes:
```go
if !bytes.Equal(current, next) {
    current = next
    out <- current
}
```

**Backoff on error** - Don't spam a failing source:
```go
if err != nil {
    time.Sleep(backoff)
    backoff = min(backoff*2, maxBackoff)
    continue
}
backoff = initialBackoff
```

**Graceful send** - Always respect context during channel sends:
```go
select {
case out <- value:
case <-ctx.Done():
    return
}
```

## Example: Environment Variable Watcher

Watch environment variables for changes (useful for container deployments):

```go
type EnvWatcher struct {
    keys     []string
    interval time.Duration
}

func NewEnvWatcher(keys []string, interval time.Duration) *EnvWatcher {
    return &EnvWatcher{keys: keys, interval: interval}
}

func (w *EnvWatcher) Watch(ctx context.Context) (<-chan []byte, error) {
    out := make(chan []byte)

    go func() {
        defer close(out)

        var current map[string]string
        ticker := time.NewTicker(w.interval)
        defer ticker.Stop()

        emit := func() {
            env := make(map[string]string)
            for _, key := range w.keys {
                env[key] = os.Getenv(key)
            }

            if current == nil || !reflect.DeepEqual(current, env) {
                current = env
                data, _ := json.Marshal(env)
                select {
                case out <- data:
                case <-ctx.Done():
                    return
                }
            }
        }

        // Initial emission
        emit()

        for {
            select {
            case <-ctx.Done():
                return
            case <-ticker.C:
                emit()
            }
        }
    }()

    return out, nil
}
```

Usage:
```go
type Config struct {
    DatabaseURL string `json:"DATABASE_URL" validate:"required"`
    LogLevel    string `json:"LOG_LEVEL"`
}

watcher := NewEnvWatcher([]string{"DATABASE_URL", "LOG_LEVEL"}, time.Minute)
capacitor := flux.New[Config](watcher, applyConfig)
```
