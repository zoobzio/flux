---
title: Architecture
description: State machine design and data flow in flux.
author: Flux Team
published: 2025-12-03
tags: [Architecture, Design, State Machine]
---

# Architecture

## Data Flow

```
Watcher ──▶ Debouncer ──▶ Unmarshal ──▶ Validate ──▶ Callback ──▶ State
   │                          │            │           │
   │                          ▼            ▼           ▼
   │                       error        error       error
   │                          │            │           │
   │                          └────────────┴───────────┘
   │                                       │
   ▼                                       ▼
Capitan signals                    State → Degraded/Empty
```

### Processing Pipeline

1. **Watcher** emits raw bytes (`[]byte`)
2. **Debouncer** coalesces rapid changes (configurable duration)
3. **Unmarshal** detects format and parses to struct `R` (automatic via struct tags)
4. **Validate** checks struct tag constraints (automatic via [go-playground/validator](https://github.com/go-playground/validator))
5. **Callback** applies validated configuration (your code)
6. **State** transitions to Healthy (or Degraded/Empty on failure)

### Automatic Format Detection

Flux automatically detects YAML vs JSON by examining the first non-whitespace character:

```
'{' or '[' → JSON
otherwise  → YAML
```

Both formats use struct tags:

```go
type Config struct {
    Port int `yaml:"port" json:"port" validate:"min=1,max=65535"`
}
```

### Initial Load

The first value bypasses debouncing:

```
Start(ctx)
    │
    ▼
watcher.Watch(ctx)
    │
    ▼
Wait for first value (blocking)
    │
    ├─▶ success: State → Healthy, return nil
    │
    └─▶ failure: State → Empty, return error
                 (continue watching async)
```

## State Machine

```
┌─────────┐   valid    ┌─────────┐
│ Loading │──────────▶│ Healthy │◀──┐
└─────────┘            └─────────┘   │
     │                      │        │
     │ invalid              │ invalid│ valid
     ▼                      ▼        │
┌─────────┐            ┌─────────┐───┘
│  Empty  │            │ Degraded│
└─────────┘            └─────────┘
```

| State | Has Config | Has Error | Meaning |
|-------|------------|-----------|---------|
| Loading | No | No | Waiting for first value |
| Healthy | Yes | No | Valid config active |
| Degraded | Yes | Yes | Update failed, previous config retained |
| Empty | No | Yes | No valid config ever obtained |

### Rollback Behavior

When an update fails:
- If a valid config exists → **Degraded** (previous config retained)
- If no valid config exists → **Empty** (nothing to fall back to)

Recovery happens automatically when a valid config arrives.

### Error Sources

Each pipeline stage can fail independently:

```go
// Unmarshal errors - YAML/JSON syntax problems
CapacitorTransformFailed

// Validation errors - struct tag violations
CapacitorValidationFailed

// Callback errors - application-level issues
CapacitorApplyFailed
```

## Debouncing

Changes are coalesced to prevent thrashing:

```
Time:     0ms    20ms   40ms   100ms  160ms
Events:   [A]    [B]    [C]
Timer:    ─────reset──reset─────fire
Process:                        [C]
```

- First change starts timer
- Subsequent changes reset timer
- Only latest value processed when timer fires

## Observability

Every lifecycle event emits a capitan signal:

| Signal | When |
|--------|------|
| `CapacitorStarted` | `Start()` called |
| `CapacitorStopped` | Context cancelled |
| `CapacitorStateChanged` | State transition |
| `CapacitorChangeReceived` | Raw bytes received |
| `CapacitorTransformFailed` | Unmarshal error |
| `CapacitorValidationFailed` | Validation error |
| `CapacitorApplyFailed` | Callback error |
| `CapacitorApplySucceeded` | Config applied |

### Hooking Signals

```go
capitan.Hook(flux.CapacitorStateChanged, func(ctx context.Context, e *capitan.Event) {
    oldState, _ := flux.KeyOldState.From(e)
    newState, _ := flux.KeyNewState.From(e)
    log.Printf("State: %s → %s", oldState, newState)
})
```

## Thread Safety

All public methods are safe for concurrent use:

```go
// Safe - atomic operations
state := capacitor.State()
cfg, ok := capacitor.Current()
err := capacitor.LastError()

// Safe - mutex protected, single-use
err := capacitor.Start(ctx)
```

## Multi-Source Composition

For multiple configuration sources, use `Compose`:

```go
capacitor := flux.Compose[Config](
    func(configs []Config) (Config, error) {
        // configs[0] = defaults
        // configs[1] = file config
        merged := configs[0]
        if configs[1].Port != 0 {
            merged.Port = configs[1].Port
        }
        return merged, nil
    },
    defaultsWatcher,
    fileWatcher,
)
```

Each source is parsed and validated independently. Your reducer receives the slice of parsed configs and returns the merged result, which is stored and accessible via `Current()`.

## Watcher Interface

The `Watcher` interface is intentionally simple:

```go
type Watcher interface {
    Watch(ctx context.Context) (<-chan []byte, error)
}
```

Watchers always emit raw bytes. Flux handles unmarshaling internally. This design:
- Separates data sourcing from parsing
- Enables custom sources without format concerns
- Allows flux to detect and handle format automatically
