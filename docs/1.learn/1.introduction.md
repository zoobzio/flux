---
title: Introduction to Flux
description: Why flux exists and what problems it solves for reactive configuration in Go applications.
author: Flux Team
published: 2025-12-03
tags: [Introduction, Overview, Concepts]
---

# Introduction to Flux

## What is Flux?

Flux is a reactive configuration synchronization library for Go. It watches external data sources, automatically unmarshals and validates incoming data using struct tags, and applies it to your application state with automatic rollback on failure.

The core primitive is the **Capacitor** - a component that accumulates changes from a source and releases them to your application in a controlled, validated manner.

## The Problem

Applications need to react to configuration changes from various sources:

```go
// Traditional approach: Manual file watching
func watchConfig(path string, apply func(Config)) {
    watcher, _ := fsnotify.NewWatcher()
    watcher.Add(path)

    for {
        select {
        case event := <-watcher.Events:
            if event.Op&fsnotify.Write != 0 {
                data, _ := os.ReadFile(path)
                var cfg Config
                yaml.Unmarshal(data, &cfg)
                apply(cfg) // What if this fails?
            }
        case err := <-watcher.Errors:
            log.Printf("error: %v", err) // Now what?
        }
    }
}
```

This approach has problems:

1. **No Validation**: Invalid configs crash or corrupt application state
2. **No Rollback**: Failed applies leave the system in an undefined state
3. **No Debouncing**: Rapid changes cause thrashing
4. **No Observability**: Hard to monitor config lifecycle
5. **No Testing**: File watching is inherently difficult to test
6. **Boilerplate**: Every project reimplements unmarshal → validate → apply

## The Flux Solution

Flux provides structured configuration synchronization with automatic handling via struct tags:

### 1. Automatic Unmarshal → Validate → Apply Pipeline

Define your config with struct tags, and flux handles the rest:

```go
type Config struct {
    Port           int    `yaml:"port" validate:"min=1,max=65535"`
    MaxConnections int    `yaml:"max_connections" validate:"min=1"`
    DatabaseURL    string `yaml:"database_url" validate:"required"`
}

capacitor := flux.New[Config](
    flux.NewFileWatcher("/etc/myapp/config.yaml"),
    func(cfg Config) error {
        // Only called with valid, parsed config
        return app.UpdateConfig(cfg)
    },
)
```

Flux automatically:
1. Detects YAML or JSON format
2. Unmarshals using `yaml`/`json` struct tags
3. Validates using `validate` struct tags ([go-playground/validator](https://github.com/go-playground/validator))
4. Only calls your callback if everything passes

### 2. Automatic Rollback

Failed updates preserve the last known good configuration:

```go
// Initial valid config: {Port: 8080}
// User writes invalid config: {Port: -1}

// Validation fails (port < min=1):
// - State → Degraded
// - Current() still returns {Port: 8080}
// - LastError() returns validation error

// User fixes config: {Port: 9090}
// Validation passes:
// - State → Healthy
// - Current() returns {Port: 9090}
// - LastError() returns nil
```

### 3. State Machine

Clear lifecycle states for operational clarity:

```go
switch capacitor.State() {
case flux.StateLoading:
    // Initial state, waiting for first config
case flux.StateHealthy:
    // Valid config applied and active
case flux.StateDegraded:
    // Last update failed, previous config still active
case flux.StateEmpty:
    // Initial load failed, no valid config ever obtained
}
```

### 4. Debounced Updates

Rapid changes are coalesced:

```go
capacitor := flux.New[Config](
    watcher,
    callback,
    flux.WithDebounce(100*time.Millisecond),
)

// File written 10 times in 50ms
// Only the final value is processed after debounce period
```

### 5. Observability via Capitan

Built-in signals for monitoring and alerting:

```go
// State transitions
capitan.Hook(flux.CapacitorStateChanged, func(ctx context.Context, e *capitan.Event) {
    oldState, _ := flux.KeyOldState.From(e)
    newState, _ := flux.KeyNewState.From(e)
    metrics.RecordStateChange(oldState, newState)
})

// Validation failures
capitan.Hook(flux.CapacitorValidationFailed, func(ctx context.Context, e *capitan.Event) {
    errMsg, _ := flux.KeyError.From(e)
    alerting.Send("Config validation failed: " + errMsg)
})
```

### 6. Testable Design

Sync mode enables deterministic testing:

```go
func TestConfigReload(t *testing.T) {
    ch := make(chan []byte, 2)
    ch <- []byte("port: 100\nmax_connections: 10")
    ch <- []byte("port: 200\nmax_connections: 20")

    var applied Config

    capacitor := flux.New[Config](
        flux.NewSyncChannelWatcher(ch),
        func(cfg Config) error {
            applied = cfg
            return nil
        },
        flux.WithSyncMode(),
    )

    capacitor.Start(ctx)
    assert.Equal(t, 100, applied.Port)

    capacitor.Process(ctx)
    assert.Equal(t, 200, applied.Port)
}
```

## When to Use Flux

### Good Fits

**File-Based Configuration**
```go
flux.NewFileWatcher("/etc/myapp/config.yaml")
```

**Feature Flags**
```go
// Watch a feature flag file/service
capacitor := flux.New[FeatureFlags](
    flagsWatcher,
    func(flags FeatureFlags) error {
        return app.SetFlags(flags)
    },
)
```

**Secret Rotation**
```go
// Watch a secrets manager
capacitor := flux.New[Secrets](
    secretsWatcher,
    func(secrets Secrets) error {
        return app.RotateSecrets(secrets)
    },
)
```

**Dynamic Routing**
```go
// Watch service discovery
capacitor := flux.New[Endpoints](
    serviceDiscoveryWatcher,
    func(endpoints Endpoints) error {
        return router.UpdateEndpoints(endpoints)
    },
)
```

### Not Ideal For

**High-Frequency Data Streams**
- Flux is for configuration, not streaming data
- Debouncing assumes changes are infrequent

**Distributed Configuration**
- Flux is single-process
- Use etcd, Consul, or similar for distributed config

**Immediate Consistency**
- Debouncing adds latency by design
- Use direct function calls for instant updates

## Design Philosophy

### 1. Safety First

Invalid data never reaches your application:

```go
// Unmarshal error → State: Empty/Degraded
// Validation error → State: Empty/Degraded
// Callback error → State: Empty/Degraded
// Only success → State: Healthy
```

### 2. Observable by Default

Every lifecycle event emits a capitan signal:

```go
CapacitorStarted         // Watch began
CapacitorStopped         // Watch ended
CapacitorStateChanged    // State transition
CapacitorChangeReceived  // Raw data received
CapacitorTransformFailed // Unmarshal error
CapacitorValidationFailed // Validation error
CapacitorApplyFailed     // Callback error
CapacitorApplySucceeded  // Success
```

### 3. Zero Boilerplate

Struct tags do the work:

```go
type Config struct {
    Port int `yaml:"port" validate:"min=1,max=65535"`
}

// That's it. Flux handles parsing and validation.
```

### 4. Testable

No time-dependent behavior in tests:

```go
// Sync mode: manual, deterministic processing
flux.WithSyncMode()

// Fake clock: controlled time for debounce testing
flux.WithClock(clockz.NewFakeClock())
```

### 5. Composable

The Watcher interface enables custom sources:

```go
type Watcher interface {
    Watch(ctx context.Context) (<-chan []byte, error)
}
```

## Next Steps

- [Core Concepts](./2.core-concepts.md) - Deep dive into capacitors, watchers, and state
- [Architecture](./3.architecture.md) - State machine design and data flow
- [Quickstart](../2.tutorials/1.quickstart.md) - Build your first config sync
