---
title: Core Concepts
description: Understanding capacitors, watchers, and state management in flux.
author: Flux Team
published: 2025-12-03
tags: [Concepts, Capacitor, Watcher, State]
---

# Core Concepts

## The Capacitor

A **Capacitor** is the central primitive in flux. Like an electrical capacitor that accumulates charge and releases it in a controlled manner, a flux Capacitor accumulates configuration changes and releases them to your application through a validated pipeline.

```go
type Capacitor[R any] struct {
    watcher  Watcher        // Source of raw bytes
    callback func(R) error  // Called with valid, parsed config
}
```

The type parameter `R` is your configuration struct type. Flux automatically:
1. Receives raw bytes from the watcher
2. Detects YAML or JSON format
3. Unmarshals to type `R`
4. Validates using struct tags
5. Calls your callback with the valid result

### Creating a Capacitor

```go
type Config struct {
    Port int `yaml:"port" validate:"min=1,max=65535"`
}

capacitor := flux.New[Config](
    watcher,    // Where to watch (emits []byte)
    callback,   // What to do with valid config
    opts...,    // Configuration
)
```

### The Processing Pipeline

Every change flows through automatic stages:

```
Raw Bytes → Detect Format → Unmarshal → Validate → Callback
               │                 │           │          │
               ▼                 ▼           ▼          ▼
           (JSON/YAML)      Unmarshal   Validation  Callback
                              Error       Error      Error
```

Each stage can fail independently:

```go
// Unmarshal: Parse errors (automatic)
// Invalid YAML/JSON → State: Empty/Degraded

// Validate: Struct tag violations (automatic)
type Config struct {
    Port int `validate:"min=1,max=65535"` // Port -1 fails here
}

// Callback: Business rule errors (your code)
func(cfg Config) error {
    if cfg.EnableCheckout && !cfg.EnableCart {
        return errors.New("checkout requires cart")
    }
    return app.SetConfig(cfg)
}
```

## Watchers

A **Watcher** is the source of raw bytes. It implements a simple interface:

```go
type Watcher interface {
    Watch(ctx context.Context) (<-chan []byte, error)
}
```

Key behaviors:
- Returns a channel that emits `[]byte` when data changes
- First emission should be the current value (for initial load)
- Channel closes when context is cancelled or source is unavailable

### Built-in Watchers

**FileWatcher** - Watches a file using fsnotify:

```go
watcher := flux.NewFileWatcher("/etc/myapp/config.yaml")
// Emits []byte on file write
// First emission is current file contents
```

**ChannelWatcher** - Wraps an existing channel:

```go
ch := make(chan []byte, 10)
watcher := flux.NewChannelWatcher(ch)
// Useful for testing or custom sources
```

**SyncChannelWatcher** - Direct channel access for testing:

```go
ch := make(chan []byte, 10)
watcher := flux.NewSyncChannelWatcher(ch)
// No intermediate goroutine
// Use with WithSyncMode() for deterministic tests
```

### Custom Watchers

Implement the interface for any data source:

```go
type HTTPWatcher struct {
    url      string
    interval time.Duration
}

func (w *HTTPWatcher) Watch(ctx context.Context) (<-chan []byte, error) {
    out := make(chan []byte)

    go func() {
        defer close(out)

        // Initial fetch
        if data, err := w.fetch(); err == nil {
            out <- data
        }

        ticker := time.NewTicker(w.interval)
        defer ticker.Stop()

        for {
            select {
            case <-ctx.Done():
                return
            case <-ticker.C:
                if data, err := w.fetch(); err == nil {
                    out <- data
                }
            }
        }
    }()

    return out, nil
}
```

## State Machine

The Capacitor maintains a state machine with four states:

```
┌─────────┐   valid    ┌─────────┐
│ Loading │──────────▶│ Healthy │◀──┐
└─────────┘            └─────────┘   │
     │                      │        │
     │ invalid              │ invalid│ valid
     ▼                      ▼        │
┌─────────┐            ┌─────────┐───┘
│  Empty  │            │ Degraded│
└─────────┘            └─────────┘
```

### States

**StateLoading**
- Initial state before first value is processed
- `Current()` returns zero value, `false`
- Transitions to Healthy or Empty

**StateHealthy**
- Valid configuration is applied and active
- `Current()` returns the config, `true`
- `LastError()` returns `nil`
- Transitions to Degraded on failure, stays Healthy on success

**StateDegraded**
- Last update failed, but previous valid config is retained
- `Current()` returns the previous valid config, `true`
- `LastError()` returns the failure reason
- Transitions to Healthy on recovery

**StateEmpty**
- Initial load failed, no valid config ever obtained
- `Current()` returns zero value, `false`
- `LastError()` returns the failure reason
- Can transition to Healthy if a valid config eventually arrives

### Accessing State

```go
// Current state
state := capacitor.State()

// Current valid configuration
cfg, ok := capacitor.Current()
if !ok {
    // No valid config (Loading or Empty state)
}

// Last error (if any)
if err := capacitor.LastError(); err != nil {
    log.Printf("Last failure: %v", err)
}
```

## Debouncing

Changes are debounced to prevent thrashing from rapid updates:

```go
capacitor := flux.New[Config](
    watcher,
    callback,
    flux.WithDebounce(100*time.Millisecond),
)
```

### How Debouncing Works

```
Time:     0ms    20ms   40ms   60ms   100ms  160ms
Events:   [A]    [B]    [C]
Timer:    ──────reset──reset──────────fire
Process:                              [C]
```

1. First change starts debounce timer
2. Subsequent changes reset the timer
3. Timer fires after no changes for the debounce duration
4. Only the latest value is processed

### Initial Load

The first value is processed immediately without debouncing:

```go
err := capacitor.Start(ctx)
// Blocks until first value is processed
// Returns error if initial load fails (but keeps watching)
```

## Multi-Source Composition

For multiple configuration sources, use `Compose`:

```go
type Config struct {
    Port    int `yaml:"port" validate:"min=1,max=65535"`
    Timeout int `yaml:"timeout"`
}

capacitor := flux.Compose[Config](
    func(configs []Config) (Config, error) {
        // configs[0] = defaults
        // configs[1] = file config
        // configs[2] = env config
        merged := configs[0]
        if configs[1].Port != 0 {
            merged.Port = configs[1].Port
        }
        // ... merge as needed
        return merged, nil
    },
    defaultsWatcher,
    fileWatcher,
    envWatcher,
)
```

Each source is parsed and validated independently. Your reducer receives the slice of parsed configs and returns the merged result, which is stored and accessible via `Current()`.

## Lifecycle

### Starting

```go
err := capacitor.Start(ctx)
```

- Calls `watcher.Watch(ctx)` to begin receiving values
- Waits for and processes first value synchronously
- Returns error if initial load fails
- Continues watching asynchronously (unless sync mode)
- Can only be called once

### Accessing Current Config

```go
// Safe concurrent access
cfg, ok := capacitor.Current()
if ok {
    // Use cfg
}
```

### Stopping

Stop by cancelling the context:

```go
ctx, cancel := context.WithCancel(context.Background())
capacitor.Start(ctx)

// Later...
cancel() // Stops watching, emits CapacitorStopped signal
```

### Observing Lifecycle

All lifecycle events emit capitan signals:

```go
capitan.Hook(flux.CapacitorStarted, func(ctx context.Context, e *capitan.Event) {
    debounce, _ := flux.KeyDebounce.From(e)
    log.Printf("Started watching, debounce=%v", debounce)
})

capitan.Hook(flux.CapacitorStateChanged, func(ctx context.Context, e *capitan.Event) {
    oldState, _ := flux.KeyOldState.From(e)
    newState, _ := flux.KeyNewState.From(e)
    log.Printf("State: %s → %s", oldState, newState)
})
```

## Next Steps

- [Architecture](./3.architecture.md) - Implementation details and data flow
- [Quickstart](../2.tutorials/1.quickstart.md) - Build your first config sync
- [Testing Guide](../3.guides/1.testing.md) - Testing patterns with sync mode
