---
title: API Reference
description: Complete API documentation for flux.
author: Flux Team
published: 2025-12-03
tags: [Reference, API, Documentation]
---

# API Reference

## Capacitor

### Type Definition

```go
type Capacitor[R any] struct {
    // contains filtered or unexported fields
}
```

A Capacitor watches a source for changes, automatically unmarshals and validates the data using struct tags, and applies it to application state with automatic rollback on failure.

Type parameter:
- `R` - Result type (your configuration struct)

### Constructor

```go
func New[R any](
    watcher Watcher,
    callback func(R) error,
    opts ...Option,
) *Capacitor[R]
```

Creates a new Capacitor with the given watcher and callback.

**Parameters:**
- `watcher` - Source of raw bytes (implements `Watcher` interface)
- `callback` - Called with valid, parsed configuration
- `opts` - Configuration options

**Automatic Processing:**
Flux automatically handles:
1. YAML/JSON format detection
2. Unmarshaling via `yaml`/`json` struct tags
3. Validation via `validate` struct tags ([go-playground/validator](https://github.com/go-playground/validator))

**Example:**
```go
type Config struct {
    Port int `yaml:"port" validate:"min=1,max=65535"`
}

capacitor := flux.New[Config](
    flux.NewFileWatcher("/etc/app/config.yaml"),
    func(cfg Config) error {
        return app.SetConfig(cfg)
    },
    flux.WithDebounce(100*time.Millisecond),
)
```

### Methods

#### Start

```go
func (c *Capacitor[R]) Start(ctx context.Context) error
```

Begins watching for changes. Blocks until the first configuration is processed (success or failure), then continues watching asynchronously.

**Returns:**
- `nil` if initial configuration loaded successfully
- Error if initial load fails (but continues watching in background)

**Behavior:**
- Can only be called once (subsequent calls return error)
- Emits `CapacitorStarted` signal
- In sync mode, only processes initial value

**Example:**
```go
ctx, cancel := context.WithCancel(context.Background())
defer cancel()

if err := capacitor.Start(ctx); err != nil {
    log.Printf("Initial load failed: %v", err)
    // Capacitor continues watching for valid config
}
```

#### State

```go
func (c *Capacitor[R]) State() State
```

Returns the current state of the Capacitor.

**Returns:** One of `StateLoading`, `StateHealthy`, `StateDegraded`, `StateEmpty`

#### Current

```go
func (c *Capacitor[R]) Current() (R, bool)
```

Returns the current valid configuration.

**Returns:**
- `(config, true)` if a valid configuration exists
- `(zero, false)` if no valid configuration (Loading or Empty state)

**Example:**
```go
if cfg, ok := capacitor.Current(); ok {
    fmt.Printf("Port: %d\n", cfg.Port)
} else {
    fmt.Println("No valid configuration")
}
```

#### LastError

```go
func (c *Capacitor[R]) LastError() error
```

Returns the last error encountered, or `nil` if no error occurred.

#### Process

```go
func (c *Capacitor[R]) Process(ctx context.Context) bool
```

Processes the next value from the watcher. Only available in sync mode.

**Returns:**
- `true` if a value was processed
- `false` if no value available, channel closed, or not in sync mode

---

## Compose

### Function

```go
func Compose[R any](
    reducer func([]R) (R, error),
    sources ...Watcher,
) *CompositeCapacitor[R]
```

Creates a CompositeCapacitor that watches multiple sources and calls the reducer with all parsed configurations.

**Parameters:**
- `reducer` - Receives slice of parsed configs (one per source, in order), returns merged result
- `sources` - Watchers to combine

**Example:**
```go
type Config struct {
    Port    int `yaml:"port" validate:"min=1,max=65535"`
    Timeout int `yaml:"timeout"`
}

capacitor := flux.Compose[Config](
    func(configs []Config) (Config, error) {
        // configs[0] = defaults
        // configs[1] = file config
        merged := configs[0]
        if configs[1].Port != 0 {
            merged.Port = configs[1].Port
        }
        return merged, nil
    },
    defaultsWatcher,
    fileWatcher,
)
```

### ComposeWithOptions

```go
func ComposeWithOptions[R any](
    reducer func([]R) (R, error),
    opts []Option,
    sources ...Watcher,
) *CompositeCapacitor[R]
```

Same as Compose but accepts options.

---

## CompositeCapacitor

### Type Definition

```go
type CompositeCapacitor[R any] struct {
    // contains filtered or unexported fields
}
```

### Methods

Same as `Capacitor[R]`:
- `Start(ctx context.Context) error`
- `State() State`
- `Current() (R, bool)` - Returns the first source's config
- `LastError() error`
- `Process(ctx context.Context) bool`

---

## Options

### WithDebounce

```go
func WithDebounce(d time.Duration) Option
```

Sets the debounce duration for change processing. Changes arriving within this duration are coalesced into a single update.

**Default:** 100ms

**Example:**
```go
flux.WithDebounce(200 * time.Millisecond)
```

### WithSyncMode

```go
func WithSyncMode() Option
```

Enables synchronous processing for testing. In sync mode:
- Changes are processed immediately without debouncing
- No async goroutines
- Use `Process()` to manually process subsequent values

**Example:**
```go
capacitor := flux.New[Config](
    flux.NewSyncChannelWatcher(ch),
    func(cfg Config) error { return nil },
    flux.WithSyncMode(),
)
```

### WithClock

```go
func WithClock(clock clockz.Clock) Option
```

Sets a custom clock for time operations. Use with `clockz.FakeClock` for deterministic debounce testing.

**Default:** `clockz.RealClock`

**Example:**
```go
clock := clockz.NewFakeClock()
capacitor := flux.New[Config](
    watcher,
    callback,
    flux.WithClock(clock),
)

// Later in test:
clock.Advance(100 * time.Millisecond)
```

### WithJSON

```go
func WithJSON() Option
```

Enforces JSON format for incoming data. If the data is not valid JSON, parsing will fail with an error.

Without this option, format is auto-detected from content.

**Example:**
```go
// Only accept JSON - YAML will be rejected
capacitor := flux.New[Config](
    watcher,
    callback,
    flux.WithJSON(),
)
```

### WithYAML

```go
func WithYAML() Option
```

Enforces YAML format for incoming data. Data is always parsed as YAML.

Note: YAML parsers accept JSON, so JSON input will still work with this option.

**Example:**
```go
// Parse as YAML (also accepts JSON)
capacitor := flux.New[Config](
    watcher,
    callback,
    flux.WithYAML(),
)
```

---

## Format

### Type Definition

```go
type Format int

const (
    FormatAuto Format = iota  // Auto-detect from content (default)
    FormatJSON                // Enforce JSON format
    FormatYAML                // Enforce YAML format
)
```

---

## State

### Type Definition

```go
type State string

const (
    StateLoading  State = "loading"
    StateHealthy  State = "healthy"
    StateDegraded State = "degraded"
    StateEmpty    State = "empty"
)
```

### Methods

#### String

```go
func (s State) String() string
```

Returns the string representation of the state.

---

## Watcher Interface

```go
type Watcher interface {
    Watch(ctx context.Context) (<-chan []byte, error)
}
```

Watcher defines the interface for data sources that emit raw bytes when data changes.

**Requirements:**
- Return a channel that emits `[]byte` on change
- Emit current value immediately (for initial load)
- Close channel when context cancelled or source unavailable
- Return error if watching cannot start

---

## FileWatcher

### Type Definition

```go
type FileWatcher struct {
    // contains filtered or unexported fields
}
```

FileWatcher watches a file for changes and emits its contents as bytes.

### Constructor

```go
func NewFileWatcher(path string) *FileWatcher
```

Creates a new FileWatcher for the given file path.

### Methods

#### Watch

```go
func (w *FileWatcher) Watch(ctx context.Context) (<-chan []byte, error)
```

Begins watching the file.

**Returns:**
- Channel that emits `[]byte` file contents on write
- Error if file cannot be watched

**Behavior:**
- Emits current file contents immediately
- Uses fsnotify for change detection
- Only emits on Write or Create events
- Closes channel when context cancelled

---

## ChannelWatcher

### Type Definition

```go
type ChannelWatcher struct {
    // contains filtered or unexported fields
}
```

ChannelWatcher wraps an existing `[]byte` channel as a Watcher.

### Constructors

#### NewChannelWatcher

```go
func NewChannelWatcher(ch <-chan []byte) *ChannelWatcher
```

Creates a ChannelWatcher that runs asynchronously, forwarding values through an internal goroutine.

#### NewSyncChannelWatcher

```go
func NewSyncChannelWatcher(ch <-chan []byte) *ChannelWatcher
```

Creates a ChannelWatcher that returns the source channel directly without an intermediate goroutine. Use with `WithSyncMode()` for deterministic testing.

### Methods

#### Watch

```go
func (w *ChannelWatcher) Watch(ctx context.Context) (<-chan []byte, error)
```

Returns a channel that forwards values from the wrapped channel.

---

## Signals

Capitan signals for observability:

```go
var (
    CapacitorStarted          // Capacitor watching started
    CapacitorStopped          // Capacitor watching stopped
    CapacitorStateChanged     // State transition
    CapacitorChangeReceived   // Raw bytes received from watcher
    CapacitorTransformFailed  // Unmarshal error
    CapacitorValidationFailed // Validation error
    CapacitorApplyFailed      // Callback error
    CapacitorApplySucceeded   // Config applied successfully
)
```

## Field Keys

Capitan field keys for event data:

```go
var (
    KeyState      // Current state (string)
    KeyOldState   // Previous state (string)
    KeyNewState   // New state (string)
    KeyError      // Error message (string)
    KeyDebounce   // Debounce duration (time.Duration)
)
```

**Usage:**
```go
capitan.Hook(flux.CapacitorStateChanged, func(ctx context.Context, e *capitan.Event) {
    oldState, _ := flux.KeyOldState.From(e)
    newState, _ := flux.KeyNewState.From(e)
    log.Printf("State: %s â†’ %s", oldState, newState)
})
```

---

## Constants

```go
const DefaultDebounce = 100 * time.Millisecond
```

DefaultDebounce is the default debounce duration for change processing.

---

## Complete Example

```go
package main

import (
    "context"
    "log"
    "os"
    "os/signal"
    "time"

    "github.com/zoobzio/flux"
)

type Config struct {
    Port    int           `yaml:"port" validate:"min=1,max=65535"`
    Timeout time.Duration `yaml:"timeout" validate:"min=1s"`
}

func main() {
    capacitor := flux.New[Config](
        flux.NewFileWatcher("config.yaml"),
        func(cfg Config) error {
            log.Printf("Applied: port=%d, timeout=%v", cfg.Port, cfg.Timeout)
            return nil
        },
        flux.WithDebounce(100*time.Millisecond),
    )

    ctx, cancel := signal.NotifyContext(context.Background(), os.Interrupt)
    defer cancel()

    if err := capacitor.Start(ctx); err != nil {
        log.Printf("Warning: %v", err)
    }

    log.Printf("State: %s", capacitor.State())

    <-ctx.Done()
}
```
